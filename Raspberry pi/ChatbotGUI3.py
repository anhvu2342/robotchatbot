# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'maindesign.ui'
#
# Created by: PyQt5 UI code generator 5.15.10
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import lipsyncprocess2
import json
from datetime import datetime
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import QTimer, QEventLoop
import speech_recognition as sr
from gtts import gTTS
import playsound
import os
import requests

key = 0

class ChatBotGUI(object):
    def __init__(self):
        self.centralwidget = None
        self.IMG_Pose_Moverment = None
        self.Pose_index = None
        self.timer = None
        self.IMG_Pose3 = None
        self.IMG_Pose2 = None
        self.IMG_Pose1 = None
        self.statusbar = None
        self.menubar = None
        self.BTN_Exit = None
        self.BTN_Clear = None
        self.BTN_Record = None
        self.LB_Mouth = None
        self.TXT_Chat = None
        self.LB_Pose = None

    def setupui(self, mainwindow):
        mainwindow.setObjectName("MainWindow")
        mainwindow.resize(720, 480)
        mainwindow.setMinimumSize(QtCore.QSize(720, 480))
        mainwindow.setMaximumSize(QtCore.QSize(720, 480))
        self.centralwidget = QtWidgets.QWidget(mainwindow)
        self.centralwidget.setObjectName("centralwidget")

        # SetupUI
        self.LB_Pose = QtWidgets.QLabel(self.centralwidget)
        self.LB_Pose.setGeometry(QtCore.QRect(500, 20, 170, 340))
        self.LB_Pose.setAlignment(QtCore.Qt.AlignCenter)
        self.LB_Pose.setObjectName("LB_Pose")
        self.TXT_Chat = QtWidgets.QTextEdit(self.centralwidget)
        self.TXT_Chat.setGeometry(QtCore.QRect(70, 80, 400, 250))
        self.TXT_Chat.setObjectName("TXT_Chat")
        self.LB_Mouth = QtWidgets.QLabel(self.centralwidget)
        self.LB_Mouth.setGeometry(QtCore.QRect(530, 180, 55, 16))
        self.LB_Mouth.setAlignment(QtCore.Qt.AlignCenter)
        self.LB_Mouth.setObjectName("LB_Mouth")
        self.BTN_Record = QtWidgets.QPushButton(self.centralwidget)
        self.BTN_Record.setGeometry(QtCore.QRect(70, 350, 150, 50))
        self.BTN_Record.setObjectName("BTN_Record")
        self.BTN_Clear = QtWidgets.QPushButton(self.centralwidget)
        self.BTN_Clear.setGeometry(QtCore.QRect(320, 350, 150, 50))
        self.BTN_Clear.setObjectName("BTN_Clear")
        self.BTN_Exit = QtWidgets.QPushButton(self.centralwidget)
        self.BTN_Exit.setGeometry(QtCore.QRect(580, 20, 100, 30))
        self.BTN_Exit.setObjectName("BTN_Exit")
        mainwindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(mainwindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 480, 26))
        self.menubar.setObjectName("menubar")
        mainwindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(mainwindow)
        self.statusbar.setObjectName("statusbar")
        mainwindow.setStatusBar(self.statusbar)

        self.retranslateui(mainwindow)
        QtCore.QMetaObject.connectSlotsByName(mainwindow)

        self.loadimage()
        self.LB_Mouth.setPixmap(QtGui.QPixmap(self.IMG_Mouths[8]).scaledToWidth(60))

        self.BTN_Record.clicked.connect(self.stchat_key)
        self.BTN_Clear.clicked.connect(self.TXT_Chat.clear)
        self.BTN_Exit.clicked.connect(mainwindow.hide)
        self.StartChatting()
        
        
    def stchat_key(self):
        global key
        key = 1
    # -------------------------------------------------------
    # Xử lý khuôn mặt động
    def non_blocking_sleep(self, milliseconds):
        loop = QEventLoop()
        QTimer.singleShot(milliseconds, loop.quit)
        loop.exec_()
    def loadimage(self):  # Tạo ma trận thứ tự hiển thị pose
        self.IMG_Mouths = [f"/home/thang/document/Datasource/mouths/m{i:02}.png" for i in range(1,22)]         # địa chỉ của tất cả mouths
        self.IMG_Poses = [f"/home/thang/document/Datasource/poses/pose00{i:02}.png" for i in range(1,90)]      # địa chỉ của poses
        self.IMG_Pose1 = QtGui.QPixmap(self.IMG_Poses[1-1]).scaledToWidth(300)              # 3 pose hiện hành: lần lượt là: mở->nhắm mắt
        self.IMG_Pose2 = QtGui.QPixmap(self.IMG_Poses[2-1]).scaledToWidth(300)
        self.IMG_Pose3 = QtGui.QPixmap(self.IMG_Poses[3-1]).scaledToWidth(300)
        self.IMG_Pose_Moverment = [self.IMG_Pose2, self.IMG_Pose3, self.IMG_Pose2, self.IMG_Pose1]
        self.LB_Pose.setPixmap(self.IMG_Pose1)
        self.Pose_index = 0
        self.timer = QTimer()
        self.timer.timeout.connect(self.pose_animation)
        self.timer.start(3000)

    def pose_animation(self):  # Hiển thị khuôn mặt lên màn hình theo thời gian đã cài
        if self.Pose_index < len(self.IMG_Pose_Moverment):
            self.LB_Pose.setPixmap(self.IMG_Pose_Moverment[self.Pose_index])
            self.Pose_index += 1
        else:
            self.Pose_index = 0
            return
        QTimer.singleShot(70, self.pose_animation)

    def changemouth(self,index):
        self.LB_Mouth.setPixmap(QtGui.QPixmap(self.IMG_Mouths[index - 1]).scaledToWidth(60))
    # -------------------------------------------------------
    # Hàm xử lý text và chuyển thành mouth animation
    # -------------------------------------------------------
    # Chatbot
    def StartChatting(self):
        self.chatThread = ChattingThread()
        self.chatThread.finished.connect(self.updatetext)
        self.chatThread.lipsyncSignal.connect(self.startlipsync)
        self.chatThread.start()

    def startlipsync(self,respondText):
        self.soundThread = PlaySoundThread()
        self.lipThread = LipsyncThread(respondText)
        self.lipThread.mouthindex.connect(self.changemouth)
        self.soundThread.start()
        QTimer.singleShot(1200,self.lipThread.start)
        #self.lipThread.start()
    def updatetext(self,text):
        self.remove_last_line()
        self.TXT_Chat.append(text)
    def remove_last_line(self):
        text = self.TXT_Chat.toPlainText()
        lines = text.split('\n')
        if lines:
            lines.pop()  # Xóa dòng cuối cùng
            self.TXT_Chat.setPlainText('\n'.join(lines))
    # -------------------------------------------------------

    def retranslateui(self, mainwindow):
        _translate = QtCore.QCoreApplication.translate
        mainwindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.LB_Pose.setText(_translate("MainWindow", "Pose"))
        self.LB_Mouth.setText(_translate("MainWindow", "Mouth"))
        self.BTN_Record.setText(_translate("MainWindow", "Nghe"))
        self.BTN_Clear.setText(_translate("MainWindow", "Xóa"))
        self.BTN_Exit.setText(_translate("MainWindow", "Thoát"))
    # -------------------------------------------------------


class ChattingThread(QtCore.QThread):
    finished = QtCore.pyqtSignal(str)
    lipsyncSignal = QtCore.pyqtSignal(str)
    def run(self):
        global key
        while(True):
            if key == 1:
                self.speechtotext()
                key = 0

    def speechtotext(self):
        recognizer = sr.Recognizer()
        with sr.Microphone() as source:
            self.finished.emit("Vui lòng chờ...")
            recognizer.adjust_for_ambient_noise(source, duration=1)
            self.finished.emit("Xin mời nói:")
            recorded_audio = recognizer.listen(source, timeout=4)
            self.finished.emit("Đã ghi âm")
        try:
            self.requestText = recognizer.recognize_google(recorded_audio, language="vi")
            self.storehistorychat("Chatbot","Tôi",self.requestText)
            self.finished.emit("Bạn: {}\n".format(self.requestText))
            self.callgptapi()
        except Exception as ex:
            self.finished.emit(str(ex))

    def callgptapi(self):
        '''
        Hàm này có chức năng gọi api của chatgpt với requestText là câu hỏi, promptText là prompt.
        Tuy nhiên có thể để prompt vào tin nhắn của "system".
        :return:
        '''
        from openai import OpenAI
        self.finished.emit("callgptapi...")

        api_key = 'Fill Your API here'

        if not api_key:
            raise ValueError("API key is not set. Please set the OPENAI_API_KEY environment variable.")

        client = OpenAI(api_key=api_key)
        self.promptText = "Bạn là chatbot hỗ trợ trẻ em. Hãy trả lời câu hỏi với nội dung ngắn gọn, phù hợp, câu trả lời không được có chữ số. Câu hỏi: " + self.requestText          # Cần xem lại: sửa lại prompt cho chuẩn
        print(self.promptText)
        chat_completion = client.chat.completions.create(
            messages=[
                {
                    "role": "system",
                    "content": "Bạn là chatbot hỗ trợ trẻ em. Hãy trả lời câu hỏi với nội dung chi tiết, phù hợp, và không được chứa chữ số",
                },
                {
                    "role": "user",
                    "content": self.requestText,
                }
            ],
            model="gpt-3.5-turbo",
            temperature=0.7,
            max_tokens=500,
            top_p=1.0,
            frequency_penalty=0.0,
            presence_penalty=0.0
        )
        self.respondText = chat_completion.choices[0].message.content
        self.storehistorychat("Chatbot","Chatbot", self.respondText)
        self.finished.emit("Chatbot: {}\n".format(self.respondText))
        self.texttospeech()
        
        
    def texttospeech(self):
        filename = 'voice.mp3'
        # Kiểm tra và xóa tệp nếu tồn tại
        if os.path.exists(filename):
            try:
                os.remove(filename)
                print(f"Đã xóa tệp cũ: {filename}")
            except PermissionError:
                print(f"Lỗi: Không thể xóa tệp {filename} vì nó đang được sử dụng.")
                return
        tts = gTTS(text=self.respondText, lang='vi')
        tts.save(filename)
        self.lipsyncSignal.emit(self.respondText)
        self.send_to_api(self.requestText, self.respondText)
        #playsound.playsound(filename)
        
    def send_to_api(self, question, answer):
        api_url = "http://103.162.21.15:3000/api/conversation/create"  # Thay thế bằng URL của API bạn
        data = {
            "question": question,
            "answer": answer,
            "code": "123456"
        }
        json_data = json.dumps(data)
        response = requests.post(api_url, headers={"Content-Type": "application/json"}, data=json_data)
        if response.status_code == 200:
            #self.finished.emit("API Response: {}".format(response.json()))
            print("API Response: {}".format(response.json()))
        else:
            print("Failed to send to API: {} {}".format(response.status_code, response.text))         
        
    def storehistorychat(self,cuoctrochuyen,user,noidung):
        with open('/home/thang/document/chathistory.json', 'r', encoding='utf-8') as file:
            du_lieu = json.load(file)
        # Tìm cuộc trò chuyện có tên là "Chatbot"
        for cuoc_tro_chuyen in du_lieu:
            if cuoc_tro_chuyen["cuoc_tro_chuyen"] == cuoctrochuyen:
                # Thêm tin nhắn mới vào cuộc trò chuyện
                tin_nhan_moi = {
                    "thoi_gian": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "nguoi_gui": user,
                    "noi_dung": noidung
                }
                cuoc_tro_chuyen["lich_su"].append(tin_nhan_moi)
        # Ghi lại nội dung đã cập nhật vào file JSON
        with open('/home/thang/document/chathistory.json', 'w', encoding='utf-8') as file:
            json.dump(du_lieu, file, ensure_ascii=False, indent=4)


class PlaySoundThread(QtCore.QThread):
    def run(self):
        self.playsound()
    def playsound(self):
        filename = 'voice.mp3'
        os.system("mplayer " + filename)

class LipsyncThread(QtCore.QThread):
    def __init__(self,respondText):
        super().__init__()
        self.respondText = respondText
    mouthindex = QtCore.pyqtSignal(int)
    mouthstate = None
    def non_blocking_sleep(self, milliseconds):
        loop = QEventLoop()
        QTimer.singleShot(milliseconds, loop.quit)
        loop.exec_()

    def changemouth(self, index):
        self.mouthindex.emit(index)
        self.mouthstate = index

    def o_a_animation(self, mouthstate, timeperchar):
        self.changemouth(mouthstate+2)
        self.non_blocking_sleep(round(timeperchar/2))
        self.changemouth(mouthstate+6)
        self.non_blocking_sleep(round(timeperchar/2))

    def a_o_animation(self,mouthstate,timeperchar):
        self.changemouth(4 - self.mouthstate % 2)
        self.non_blocking_sleep(round(timeperchar/2))
        self.changemouth(2 - self.mouthstate % 2)
        self.non_blocking_sleep(round(timeperchar/2))

    def run(self):
        print(self.respondText)
        self.lipsync(self.respondText)

    def lipsync(self, paragraph):
        self.o_a_animationstate = 0
        paragraph = lipsyncprocess2.remove_diacritics(paragraph)
        print(paragraph)
        for sentence in paragraph.split("."):
            print(sentence)
            #self.non_blocking_sleep(400)
            for word in sentence.split():
                print(word)
                initial, medial, final = lipsyncprocess2.split_syllable(word)
                timeperchar = round(0.18 / (2 + len(medial)) * 1000)
                # Check initial
                if initial in ['m', 'b', 'p']:  # môi khép
                    self.changemouth(11)
                    print(initial)
                elif initial in ['ph', 'v']:    # cắn môi
                    self.changemouth(10)
                    print(initial)
                elif initial in ['q']:          # chữ o
                    self.changemouth(1)
                    print(initial)
                else:
                    print(initial)
                    pass
                self.non_blocking_sleep(timeperchar)
                # Check medial
                for char in medial:
                    if char in ['a', 'ă', 'â', 'ê', 'ơ']:
                        if self.mouthstate in [1, 2]:
                            self.o_a_animation(self.mouthstate, timeperchar)
                            pass
                            # Cần xem lại: phải có animation lần lượt chứ ko phải plot 1 hình là được
                            # Đã fix lỗi trên, vẫn cần xem lại
                        else:
                            self.changemouth(8)
                        print(char)
                    elif char in ['e', 'i', 'ư', 'y']:
                        self.changemouth(6)
                        print(char)
                    elif char in ['o', 'ô', 'u']:
                        # Cần xem lại: phải có animation
                        # Cần xem
                        if self.mouthstate in [5,6,7,8,9]:
                            self.a_o_animation(self.mouthstate,timeperchar)
                        self.changemouth(1)
                        print(char)
                    else:
                        self.changemouth(1)
                    self.non_blocking_sleep(timeperchar)
                # Check final
                if final in ['m', 'p']:  # khép môi
                    self.changemouth(11)
                    print(final)
                elif final in ['nh', 'c', 'n', 'ch', 't']:  # răng cắn
                    self.changemouth(9)
                    print(final)
                elif final in ['ng']:  # cho nhỏ miệng lại
                    print(final)
                else:  # cho nhỏ miệng lại
                    print(final)
                self.non_blocking_sleep(timeperchar)
            self.non_blocking_sleep(350)
        # Đưa khuôn miệng trở về trạng thái ban đầu
        self.changemouth(9)


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = ChatBotGUI()
    ui.setupui(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
